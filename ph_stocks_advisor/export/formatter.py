"""
Output formatter abstraction and shared utilities.

Provides :class:`OutputFormatter`, the base class that all export formats
(PDF, HTML, …) must implement, plus shared helpers such as
:func:`parse_sections` and the generic :func:`export_cli` entry point.

**Open/Closed Principle** — new formats are added by subclassing
``OutputFormatter`` and registering the class; existing code is unchanged.

**Dependency Inversion** — consumers depend on the ``OutputFormatter``
abstraction, never on a concrete format implementation.
"""

from __future__ import annotations

import abc
import re
import sys
from datetime import datetime
from pathlib import Path

from ph_stocks_advisor.infra.config import get_repository, get_settings, _parse_tz
from ph_stocks_advisor.infra.repository import ReportRecord


# ---------------------------------------------------------------------------
# Disclaimer & data-source attribution (shared by every output format)
# ---------------------------------------------------------------------------

DISCLAIMER = (
    "This report was generated by an AI system and is for informational purposes only. "
    "It does not constitute financial advice. Always consult a licensed financial "
    "advisor before making investment decisions."
)

DATA_SOURCES = (
    "Data Sources: DragonFi (api.dragonfi.ph), PSE EDGE (edge.pse.com.ph), "
    "TradingView Scanner, Tavily Web Search"
)


def format_timestamp(dt_val: datetime | None) -> str:
    """Format a UTC datetime to the user's configured timezone.

    Returns an empty string when *dt_val* is ``None``.
    """
    if dt_val is None:
        return ""
    tz = _parse_tz(get_settings().timezone)
    local_dt = dt_val.astimezone(tz)
    return local_dt.strftime("%B %d, %Y %I:%M %p")


# ---------------------------------------------------------------------------
# Shared summary parser (used by every formatter)
# ---------------------------------------------------------------------------

def _strip_trailing_dashes(line: str) -> str:
    """Remove trailing sequences of dashes/hyphens (``--``, ``----``, …).

    The LLM occasionally appends decorative dashes to the end of bullet
    points or paragraphs.  These look fine in plain text but leak through
    as raw characters in formatted output.
    """
    return re.sub(r"-{2,}\s*$", "", line)


def _clean_title(title: str) -> str:
    """Normalise an extracted section title.

    Strips trailing colons, dashes, whitespace, and markdown bold markers
    that the LLM occasionally mixes into headings.
    """
    title = re.sub(r"-{2,}", "", title)   # remove runs of 2+ dashes anywhere
    title = re.sub(r"\*{2,}", "", title)  # remove leftover bold markers
    return title.strip().rstrip(":")


def parse_sections(summary: str) -> list[tuple[str, str]]:
    """Split a consolidated summary into ``(title, body)`` pairs.

    Recognises heading patterns produced by the consolidator:

    * ``**Title:**`` on its own line  (and variants like ``**Title:----**``)
    * ``**Title**`` on its own line   (bold, no colon)
    * ``**Title:** inline content``
    * ``### Title`` / ``## Title`` (Markdown ATX headings)

    Lines consisting solely of dashes (``---``, ``----``, …) are dropped.
    Trailing dash sequences on content lines and titles are stripped.
    """
    sections: list[tuple[str, str]] = []
    current_title = "Executive Summary"
    current_lines: list[str] = []

    for line in summary.splitlines():
        stripped = line.strip()

        # Skip separator lines made entirely of dashes (2+)
        if re.fullmatch(r"-{2,}", stripped):
            continue

        # --- Bold heading on its own line ---
        # Matches:  **Price Analysis:**
        #           **Price Analysis:----**
        #           **Price Analysis----:**
        #           **Price Analysis**          (no colon)
        heading_match = re.match(
            r"^\*\*(.+?)(?::[-\s]*\*\*|-{2,}:\*\*|:\*\*|\*\*)\s*$", stripped
        )
        if heading_match:
            if current_lines:
                sections.append((current_title, "\n".join(current_lines)))
                current_lines = []
            current_title = _clean_title(heading_match.group(1))
            continue

        # --- Bold heading with inline body:  **Price Analysis:** text ---
        heading_inline = re.match(r"^\*\*(.+?):\*\*\s+(.+)$", stripped)
        if heading_inline:
            if current_lines:
                sections.append((current_title, "\n".join(current_lines)))
                current_lines = []
            current_title = _clean_title(heading_inline.group(1))
            current_lines.append(_strip_trailing_dashes(heading_inline.group(2)))
            continue

        # --- Markdown ATX heading:  ## Title  or  ### Title ---
        md_heading = re.match(r"^#{1,6}\s+(.+?)\s*$", stripped)
        if md_heading:
            if current_lines:
                sections.append((current_title, "\n".join(current_lines)))
                current_lines = []
            current_title = _clean_title(md_heading.group(1))
            continue

        current_lines.append(_strip_trailing_dashes(line))

    if current_lines:
        sections.append((current_title, "\n".join(current_lines)))

    return sections


# ---------------------------------------------------------------------------
# Abstract base class
# ---------------------------------------------------------------------------

class OutputFormatter(abc.ABC):
    """Base class every report-export format must implement.

    Subclasses provide format-specific rendering; shared behaviour
    (file writing, CLI scaffold) is handled here.
    """

    @property
    @abc.abstractmethod
    def file_extension(self) -> str:
        """File extension **including the dot** (e.g. ``'.pdf'``)."""

    @property
    @abc.abstractmethod
    def format_label(self) -> str:
        """Human-readable label shown in CLI output (e.g. ``'PDF'``)."""

    @property
    @abc.abstractmethod
    def emoji(self) -> str:
        """Single emoji used to prefix CLI success messages."""

    @abc.abstractmethod
    def render(self, record: ReportRecord) -> bytes:
        """Render *record* into the target format and return raw bytes.

        For text-based formats (HTML, Markdown, …) return
        ``text.encode("utf-8")``.
        """

    # -- concrete helpers ----------------------------------------------------

    def write(self, record: ReportRecord, path: Path) -> None:
        """Render *record* and write the result to *path*."""
        path.write_bytes(self.render(record))


# ---------------------------------------------------------------------------
# Generic CLI entry point (reusable by every format)
# ---------------------------------------------------------------------------

def export_cli(formatter: OutputFormatter) -> None:
    """Standalone CLI that fetches a saved report and exports it.

    Provides a consistent ``symbol [--id N] [-o PATH]`` interface
    regardless of the output format.
    """
    import argparse

    parser = argparse.ArgumentParser(
        description=f"Export a saved stock report as {formatter.format_label}.",
    )
    parser.add_argument("symbol", help="Stock symbol (e.g. MREIT)")
    parser.add_argument(
        "--id", type=int, default=None,
        help="Specific report ID (default: latest)",
    )
    parser.add_argument(
        "-o", "--output", type=str, default=None,
        help=f"Output path (default: <SYMBOL>_report{formatter.file_extension})",
    )
    args = parser.parse_args()

    symbol = args.symbol.upper().replace(".PS", "")

    repo = get_repository()
    try:
        if args.id:
            record = repo.get_by_id(args.id)
            if record and record.symbol != symbol:
                print(
                    f"⚠️  Report id={args.id} is for {record.symbol}, not {symbol}"
                )
        else:
            record = repo.get_latest_by_symbol(symbol)
    finally:
        repo.close()

    if record is None:
        print(f"❌ No report found for {symbol}.")
        sys.exit(1)

    print(
        f"{formatter.emoji} Exporting report id={record.id} for {record.symbol} "
        f"(verdict: {record.verdict}, date: {record.created_at})…"
    )

    out_path = Path(args.output or f"{symbol}_report{formatter.file_extension}")
    formatter.write(record, out_path)
    print(f"✅ {formatter.format_label} saved to {out_path}")
